/*!
 * \file
 * \brief file bme280_reader.c
 *
 * BME280 reader
 *
 * Copyright of Timo Hannukkala. All rights reserved.
 *
 * \author Timo Hannukkala <timohannukkala@hotmail.com>
 */
#include "bme280_reader.h"
#include <stdio.h>
#include <string.h>
#include "driver/i2c.h"
#include "driver/gpio.h"
#include "tcpip_sender.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#define SDA_PIN             GPIO_NUM_21
#define SCL_PIN             GPIO_NUM_22
#define I2C_PORT_NUMBER     I2C_NUM_0

#define I2C_MASTER_ACK      0
#define I2C_MASTER_NACK     1
#define I2C_CLOCK_SPEED     1000000

static bme280_calib_data m_calibData;
static bme280_raw_data m_rawData;

static void bme280_i2c_master_init()
{
    i2c_config_t i2c_config = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = SDA_PIN,
        .scl_io_num = SCL_PIN,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_CLOCK_SPEED
    };
    i2c_param_config(I2C_PORT_NUMBER, &i2c_config);
    i2c_driver_install(I2C_PORT_NUMBER, I2C_MODE_MASTER, 0, 0, 0);
}

bool bme280_I2C_bus_write(uint8_t reg_addr, uint8_t reg_data)
{
    esp_err_t espRc;
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (BME280_ADDRESS << 1) | I2C_MASTER_WRITE, true);

    i2c_master_write_byte(cmd, reg_addr, true);
    i2c_master_write(cmd, &reg_data, 1, true);
    i2c_master_stop(cmd);

    espRc = i2c_master_cmd_begin(I2C_PORT_NUMBER, cmd, 10/portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);

    return espRc == ESP_OK;
}


static bool bme280_I2C_bus_read(uint8_t register_address, uint8_t *data_out, uint8_t data_size)
{
    esp_err_t espRc;

    i2c_cmd_handle_t cmd = i2c_cmd_link_create();

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (BME280_ADDRESS << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, register_address, true);

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (BME280_ADDRESS << 1) | I2C_MASTER_READ, true);

    if (data_size > 1) {
        i2c_master_read(cmd, data_out, data_size-1, I2C_MASTER_ACK);
    }
    i2c_master_read_byte(cmd, data_out+data_size-1, I2C_MASTER_NACK);
    i2c_master_stop(cmd);

    espRc = i2c_master_cmd_begin(I2C_PORT_NUMBER, cmd, 10/portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);

    return espRc == ESP_OK;
}

static uint16_t bme280_I2C_bus_read_16(uint8_t register_address)
{
    uint8_t data[2];
    if (!bme280_I2C_bus_read(register_address, data, 2)) {
        return 0;
    }
    uint16_t ret;
    memcpy(&ret, data, 2);
    return ret;

}

static uint8_t bme280_I2C_bus_read_8(uint8_t register_address)
{
    uint8_t ret = 0;
    bme280_I2C_bus_read(register_address, &ret, 1);
    return ret;
}

/*!
 *	@brief bme280_reader_calibration
 *	calibration parameters used for calculation in the registers
 *
 *  parameter | Register address |   bit
 *------------|------------------|----------------
 *	dig_T1    |  0x88 and 0x89   | from 0 : 7 to 8: 15
 *	dig_T2    |  0x8A and 0x8B   | from 0 : 7 to 8: 15
 *	dig_T3    |  0x8C and 0x8D   | from 0 : 7 to 8: 15
 *	dig_P1    |  0x8E and 0x8F   | from 0 : 7 to 8: 15
 *	dig_P2    |  0x90 and 0x91   | from 0 : 7 to 8: 15
 *	dig_P3    |  0x92 and 0x93   | from 0 : 7 to 8: 15
 *	dig_P4    |  0x94 and 0x95   | from 0 : 7 to 8: 15
 *	dig_P5    |  0x96 and 0x97   | from 0 : 7 to 8: 15
 *	dig_P6    |  0x98 and 0x99   | from 0 : 7 to 8: 15
 *	dig_P7    |  0x9A and 0x9B   | from 0 : 7 to 8: 15
 *	dig_P8    |  0x9C and 0x9D   | from 0 : 7 to 8: 15
 *	dig_P9    |  0x9E and 0x9F   | from 0 : 7 to 8: 15
 *	dig_H1    |         0xA1     | from 0 to 7
 *	dig_H2    |  0xE1 and 0xE2   | from 0 : 7 to 8: 15
 *	dig_H3    |         0xE3     | from 0 to 7
 *	dig_H4    |  0xE4 and 0xE5   | from 4 : 11 to 0: 3
 *	dig_H5    |  0xE5 and 0xE6   | from 0 : 3 to 4: 11
 *	dig_H6    |         0xE7     | from 0 to 7
 *
 */
static void bme280_reader_calibration()
{
    m_calibData.dig_T1 = (uint16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_T1);
    m_calibData.dig_T2 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_T2);
    m_calibData.dig_T3 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_T3);

    m_calibData.dig_P1 = (uint16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_P1);
    m_calibData.dig_P2 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_P2);
    m_calibData.dig_P3 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_P3);
    m_calibData.dig_P4 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_P4);
    m_calibData.dig_P5 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_P5);
    m_calibData.dig_P6 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_P6);
    m_calibData.dig_P7 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_P7);
    m_calibData.dig_P8 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_P8);
    m_calibData.dig_P9 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_P9);

    m_calibData.dig_H1 = (uint8_t)bme280_I2C_bus_read_8(BME280_REGISTER_DIG_H1);
    m_calibData.dig_H2 = (int16_t)bme280_I2C_bus_read_16(BME280_REGISTER_DIG_H2);
    m_calibData.dig_H3 = (uint8_t)bme280_I2C_bus_read_8(BME280_REGISTER_DIG_H3);
    m_calibData.dig_H4 = (bme280_I2C_bus_read_8(BME280_REGISTER_DIG_H4) << 4) | (bme280_I2C_bus_read_8(BME280_REGISTER_DIG_H4+1) & 0xF);
    m_calibData.dig_H5 = (bme280_I2C_bus_read_8(BME280_REGISTER_DIG_H5+1) << 4) | (bme280_I2C_bus_read_8(BME280_REGISTER_DIG_H5) >> 4);
    m_calibData.dig_H6 = (int8_t)bme280_I2C_bus_read_8(BME280_REGISTER_DIG_H6);
}

void bme280_reader_init()
{
    bme280_i2c_master_init();
    uint8_t data = 0;
    for (int i=0;i<10;i++)
    {
        data = 0;
        bme280_I2C_bus_read(BME280_REGISTER_CHIPID, &data, sizeof(data));
        if (data == BME280_REGISTER_CHIPID_READ_VALUE) {
            break;
        }
        vTaskDelay(1);
    }
    bme280_reader_calibration();
}

static float compensateTemperature(int32_t t_fine) {
    float T  = (t_fine * 5 + 128) >> 8;
    return T/100;
}

static int32_t getTemperatureCalibration(bme280_calib_data *cal, int32_t adc_T) {
    int32_t var1  = ((((adc_T>>3) - ((int32_t)cal->dig_T1 <<1))) * ((int32_t)cal->dig_T2)) >> 11;
    int32_t var2  = (((((adc_T>>4) - ((int32_t)cal->dig_T1)) * ((adc_T>>4) - ((int32_t)cal->dig_T1))) >> 12) * ((int32_t)cal->dig_T3)) >> 14;
    return var1 + var2;
}

static float compensatePressure(int32_t adc_P, bme280_calib_data *cal, int32_t t_fine) {
    int64_t var1, var2, p;
    var1 = ((int64_t)t_fine) - 128000;
    var2 = var1 * var1 * (int64_t)cal->dig_P6;
    var2 = var2 + ((var1*(int64_t)cal->dig_P5)<<17);
    var2 = var2 + (((int64_t)cal->dig_P4)<<35);
    var1 = ((var1 * var1 * (int64_t)cal->dig_P3)>>8) + ((var1 * (int64_t)cal->dig_P2)<<12);
    var1 = (((((int64_t)1)<<47)+var1))*((int64_t)cal->dig_P1)>>33;

    if (var1 == 0) {
        return 0;
    }
    p = 1048576 - adc_P;
    p = (((p<<31) - var2)*3125) / var1;
    var1 = (((int64_t)cal->dig_P9) * (p>>13) * (p>>13)) >> 25;
    var2 = (((int64_t)cal->dig_P8) * p) >> 19;

    p = ((p + var1 + var2) >> 8) + (((int64_t)cal->dig_P7)<<4);
    return (float)p/256;
}


static float compensateHumidity(int32_t adc_H, bme280_calib_data *cal, int32_t t_fine)
{
    int32_t v_x1_u32r;
    v_x1_u32r = (t_fine - ((int32_t)76800));

    v_x1_u32r = (((((adc_H << 14) - (((int32_t)cal->dig_H4) << 20) -
      (((int32_t)cal->dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
         (((((((v_x1_u32r * ((int32_t)cal->dig_H6)) >> 10) *
        (((v_x1_u32r * ((int32_t)cal->dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
      ((int32_t)2097152)) * ((int32_t)cal->dig_H2) + 8192) >> 14));

    v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) *
           ((int32_t)cal->dig_H1)) >> 4));

    v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r;
    v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r;
    float h = (v_x1_u32r>>12);
    return  h / 1024.0;
}

void bme280_reader_task()
{
    uint8_t data[8];
    while (1) {
        vTaskDelay(1);

        bme280_I2C_bus_write(0xf2, 0x01);
        bme280_I2C_bus_write(0xf4, 0x25);
        if (bme280_I2C_bus_read(BME280_REGISTER_PRESSUREDATA, data, 8)) {
            m_rawData.pmsb = data[0];
            m_rawData.plsb = data[1];
            m_rawData.pxsb = data[2];
            m_rawData.tmsb = data[3];
            m_rawData.tlsb = data[4];
            m_rawData.txsb = data[5];
            m_rawData.hmsb = data[6];
            m_rawData.hlsb = data[7];

            m_rawData.temperature = 0;
            m_rawData.temperature = (m_rawData.temperature | m_rawData.tmsb) << 8;
            m_rawData.temperature = (m_rawData.temperature | m_rawData.tlsb) << 8;
            m_rawData.temperature = (m_rawData.temperature | m_rawData.txsb) >> 4;

            m_rawData.pressure = 0;
            m_rawData.pressure = (m_rawData.pressure | m_rawData.pmsb) << 8;
            m_rawData.pressure = (m_rawData.pressure | m_rawData.plsb) << 8;
            m_rawData.pressure = (m_rawData.pressure | m_rawData.pxsb) >> 4;

            m_rawData.humidity = 0;
            m_rawData.humidity = (m_rawData.humidity | m_rawData.hmsb) << 8;
            m_rawData.humidity = (m_rawData.humidity | m_rawData.hlsb);

            int32_t t_fine = getTemperatureCalibration(&m_calibData, m_rawData.temperature);
            float t = compensateTemperature(t_fine); // C
            float p = compensatePressure(m_rawData.pressure, &m_calibData, t_fine);
            float h = compensateHumidity(m_rawData.humidity, &m_calibData, t_fine);
 //           printf("Temp: %f Presure: %f Humid: %f %ld\n", t, p, h, m_rawData.temperature);

            tcpip_setNewValue(SensorTypeTemperature, (double)(t));
            tcpip_setNewValue(SensorTypeHumid, (double)(h));
            tcpip_setNewValue(SensorTypePresure, (double)(p));
        }
    }
	vTaskDelete(NULL);
}
